<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Regex Crossword Puzzle</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #settings-panel {
            display: none;
            margin-top: 10px;
        }

        #toggle-settings {
            background-color: #4caf50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #toggle-settings:hover {
            background-color: #45a049;
        }

        .setting-item {
            margin: 10px 0;
        }

        label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        input[type="checkbox"] {
            margin-right: 10px;
        }

        select {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            border-radius: 3px;
            border: 1px solid #ccc;
        }

        #check-solution {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #check-solution:hover {
            background-color: #45a049;
        }

        #difficulty {
            display: block;
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            font-size: 16px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        #difficulty:hover {
            border-color: #888;
        }

        #difficulty:focus {
            outline: none;
            border-color: #4caf50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.5);
        }

        select,
        button {
            cursor: pointer;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
</head>

<body>
    <div id="score-display"
        style="display:none;position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 24px; color: white; z-index: 1001;">
        Score: 0</div>
    <script type="module">
        import * as THREE from "three";
        import { OrbitControls } from "three/addons/controls/OrbitControls.js";
        import { FontLoader } from "three/addons/loaders/FontLoader.js";
        import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
        import { SimplexNoise } from "three/addons/math/SimplexNoise.js";

        let scene, camera, renderer, controls, font;
        const cubes = [];
        let SELECTION = null;
        let HOVER = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let score, par;

        // Game settings
        const settings = {
            highlightMatching: false,
            showSolution: false,
            difficulty: "easy",
        };

        // Puzzle data
        const puzzles = {
            easy: {
                words: ["RAT", "DOG", "CAT"],
                patterns: [
                    [/[RDC]/, /[AOA]/, /[TGT]/],
                    [/[RAC]/, /[DA]/, /[TOT]/],
                ],
            },
            medium: {
                words: ["REGEX", "PARSE", "MATCH"],
                patterns: [
                    [/[RPM]/, /[AE]/, /[RG]/, /[SE]/, /[EX]/],
                    [/[RP]/, /[EA]/, /[GM]/, /[EA]/, /[XT]/],
                ],
            },
            hard: {
                words: ["PUZZLE", "SOLVER", "GENIUS"],
                patterns: [
                    [/[PSG]/, /[UOE]/, /[ZLN]/, /[ZVI]/, /[LVU]/, /[ERS]/],
                    [/[P-S]/, /[O-U]/, /[L-N]/, /[S-V]/, /[E-I]/, /[R-U]/],
                ],
            },
            expert: {
                words: ["COMPLEX", "PUZZLER", "CHALLENGE"],
                patterns: [
                    [/[CP]/, /[OU]/, /[MZ]/, /[PZ]/, /[LZ]/, /[EL]/, /[XR]/],
                    [/[C-P]/, /[O-U]/, /[M-Z]/, /[P-Z]/, /[L-Z]/, /[E-R]/, /[X-Z]/],
                ],
            },
            master: {
                words: ["MASTERY", "EXPERTS", "GENIUSE"],
                patterns: [
                    [/[MEG]/, /[AEX]/, /[SPE]/, /[TTR]/, /[ERY]/, /[RSE]/, /[YTS]/],
                    [/[E-M]/, /[A-X]/, /[P-S]/, /[R-T]/, /[E-R]/, /[R-V]/, /[S-Y]/],
                ],
            },
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                1000
            );
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.update();

            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            window.addEventListener("resize", onWindowResize);
            document.addEventListener("mousedown", onDocumentMouseDown);
            document.addEventListener("mousemove", onDocumentMouseMove);
            document.addEventListener("keydown", onKeyDown);

            createTitleScreen();
        }

        function createTitleScreen() {
            scene.clear();

            // Create background pattern
            createBackgroundPattern();

            // Create glowy title
            createGlowyTitle("Regex Crossword", 0, 60, 0);

            const menuOptions = [
                { text: "Play", y: 20, onClick: () => transitionToLevelSelector() },
                { text: "Create", y: -10, onClick: () => console.log("Create option clicked"), disabled: true },
                { text: "Browse", y: -40, onClick: () => console.log("Browse option clicked"), disabled: true }
            ];

            menuOptions.forEach((option, index) => {
                createMenuOption(option.text, 0, option.y, 0, option.onClick, index * 200, option.disabled);
            });
            animateCameraToPosition(0, 0, 200);

        }
        function createBackgroundPattern() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const size = 400;
            const density = 2000; // Increased density for more particles

            // Create a 3D simplex noise function
            const noise = new SimplexNoise();

            const spreadX = 3.5;
            const spreadY = 2.5;
            const spreadZ = 2.5;
            const noiseScale = 10; // Controls the "roughness" of the distribution
            const initialNoiseScale = 0.5;
            const dispersionFactor = -0.2; // Controls how much the particles deviate from the central line

            for (let i = 0; i < density; i++) {
                const t = i / density;

                // Base position along a line
                let x = size * spreadX * (t - 0.5);
                let y = size * spreadY * (t - 0.5);
                let z = size * spreadZ * (t - 0.5);

                // Add noise-based dispersion
                x += size * dispersionFactor * (noise.noise3d(t * noiseScale, 0, 0) - 0.5);
                y += size * dispersionFactor * (noise.noise3d(0, t * noiseScale, 0) - 0.5);
                z += size * dispersionFactor * (noise.noise3d(0, 0, t * noiseScale) - 0.5);

                vertices.push(x, y, z);

                // Create a more vibrant color palette
                const hue = (noise.noise4d(t, t * 0.5, 0, 0) * 0.5 + 0.5) * 0.7 + 0.3;
                const saturation = 0.8;
                const lightness = 0.6;
                const color = new THREE.Color().setHSL(hue, saturation, lightness);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                vertexColors: true,
                size: 1,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending,
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // Animate background points
            const duration = 2000; // Longer duration for a slower, more mesmerizing effect
            const startTime = Date.now();

            function animateBackground() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                points.material.opacity = progress * 0.8;

                const positions = points.geometry.attributes.position.array;
                const colors = points.geometry.attributes.color.array;
                const count = positions.length / 3;

                // Evolve noiseScale over time
                const noiseScale = initialNoiseScale + Math.sin(elapsedTime * 0.001) * 0.3;

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const time = elapsedTime * 0.0001;
                    const offset = i * 0.01;

                    // Use evolving noiseScale for position updates
                    positions[i3] += noise.noise4d(positions[i3] * noiseScale, positions[i3 + 1] * noiseScale, positions[i3 + 2] * noiseScale, time) * 0.2;
                    positions[i3 + 1] += noise.noise4d(positions[i3 + 1] * noiseScale, positions[i3 + 2] * noiseScale, positions[i3] * noiseScale, time) * 0.2;
                    positions[i3 + 2] += noise.noise4d(positions[i3 + 2] * noiseScale, positions[i3] * noiseScale, positions[i3 + 1] * noiseScale, time) * 0.2;

                    // Slowly shift colors over time
                    const hue = (noise.noise4d(offset, time, 0, 0) * 0.5 + 0.5) * 0.7 + 0.3;
                    const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;
                }

                points.geometry.attributes.position.needsUpdate = true;
                points.geometry.attributes.color.needsUpdate = true;

                requestAnimationFrame(animateBackground);
            }

            animateBackground();
        }

        function createGlowyTitle(text, x, y, z) {
            const loader = new FontLoader();
            loader.load(
                "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/fonts/helvetiker_bold.typeface.json",
                (loadedFont) => {
                    font = loadedFont;
                    const geometry = new TextGeometry(text, {
                        font: font,
                        size: 20,
                        height: 2,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.5,
                        bevelSize: 0.3,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });

                    const material = new THREE.MeshPhongMaterial({
                        color: 0x00ffff,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0,
                        shininess: 100,
                        transparent: true,
                        opacity: 0
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);

                    // Center the title
                    geometry.computeBoundingBox();
                    mesh.position.x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                    // Add point light for glow effect
                    const pointLight = new THREE.PointLight(0x00ffff, 0, 100);
                    pointLight.position.set(x, y, z + 20);
                    scene.add(pointLight);

                    // Animate title appearance
                    const duration = 1500;
                    const startTime = Date.now();

                    function animateTitle() {
                        const elapsedTime = Date.now() - startTime;
                        const progress = Math.min(elapsedTime / duration, 1);

                        mesh.material.emissiveIntensity = progress * 0.5;
                        mesh.material.opacity = progress;
                        pointLight.intensity = progress;

                        if (progress < 1) {
                            requestAnimationFrame(animateTitle);
                        }
                    }

                    animateTitle();
                }
            );
        }

        function createMenuOption(text, x, y, z, onClick, delay = 0, disabled = false) {
            const loader = new FontLoader();
            loader.load(
                "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/fonts/helvetiker_bold.typeface.json",
                (loadedFont) => {
                    font = loadedFont;
                    const geometry = new TextGeometry(text, {
                        font: font,
                        size: 10,
                        height: 1,
                        curveSegments: 12,
                    });

                    const material = new THREE.MeshPhongMaterial({
                        color: disabled ? 0x888888 : 0xffffff,
                        emissive: disabled ? 0x444444 : 0xffffff,
                        emissiveIntensity: 0,
                        transparent: true,
                        opacity: 0
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);

                    // Center the text
                    geometry.computeBoundingBox();
                    mesh.position.x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                    // Make the option clickable
                    mesh.userData = { onClick: onClick };

                    // Animate menu option appearance
                    const duration = 1000;
                    const startTime = Date.now() + delay;

                    function animateMenuOption() {
                        const elapsedTime = Date.now() - startTime;
                        if (elapsedTime < 0) {
                            requestAnimationFrame(animateMenuOption);
                            return;
                        }

                        const progress = Math.min(elapsedTime / duration, 1);

                        mesh.material.emissiveIntensity = progress * 0.2;
                        mesh.material.opacity = progress;
                        mesh.position.z = (1 - progress) * 20;

                        if (progress < 1) {
                            requestAnimationFrame(animateMenuOption);
                        }
                    }

                    animateMenuOption();
                }
            );
        }
        function transitionToLevelSelector() {
            const duration = 1000;
            const startTime = Date.now();

            function fadeOut() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                scene.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 1 - progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(fadeOut);
                } else {
                    createLevelSelector3D();
                }
            }

            fadeOut();
        }

        function createLevelSelector3D() {
            scene.clear();

            createBackgroundPattern();
            createGlowyTitle("Select Level", 0, 80, 0);

            const levels = ["easy", "medium", "hard", "expert", "master"];
            levels.forEach((level, index) => {
                createLevelOption(level, 0, 20 - index * 25, 0, index * 200);
            });

            animateCameraToPosition(0, 0, 200);
        }


        function onDocumentMouseMove(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (intersectedObject.userData.level) {
                    if (intersectedObject !== HOVER) {
                        if (HOVER && HOVER.userData.level) {
                            HOVER.material.emissive.setHex(COLORS.BUTTON_BACKGROUND_HOVER);
                        }
                        HOVER = intersectedObject;
                        HOVER.material.emissive.setHex(COLORS.BUTTON_BACKGROUND);
                    }
                } else if (intersectedObject.isMesh && intersectedObject !== HOVER) {
                    if (HOVER) {
                        if (HOVER.userData.level) {
                            HOVER.material.emissive.setHex(0x000000);
                        } else if (HOVER.group) {
                            HOVER.group.clear();
                            if (HOVER.input) {
                                createText(HOVER, HOVER.input);
                            }
                        }
                    }
                    HOVER = intersectedObject;
                    if (!HOVER.locked) {
                        dimOtherCubes(HOVER);
                        if (HOVER.group) {
                            showHint(HOVER);
                        }
                    } else {
                        resetCubeDimming();
                    }
                }
            } else if (HOVER) {
                if (HOVER.userData.level) {
                    HOVER.material.emissive.setHex(COLORS.BUTTON_BACKGROUND_HOVER);
                } else if (HOVER.group) {
                    HOVER.group.clear();
                    if (HOVER.input) {
                        createText(HOVER, HOVER.input);
                    }
                }
                HOVER = null;
                resetCubeDimming();
            }
        }


        function onDocumentMouseDown(event) {
            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (intersectedObject.userData.onClick) {
                    intersectedObject.userData.onClick();
                } else if (intersectedObject.userData.level) {
                    settings.difficulty = intersectedObject.userData.level;
                    transitionToGame();
                } else {
                    handleGameClick(intersectedObject);
                }
            }
        }

        function createLevelOption(level, x, y, z, delay = 0) {
            const loader = new FontLoader();
            loader.load(
                "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/fonts/helvetiker_bold.typeface.json",
                (loadedFont) => {
                    font = loadedFont;
                    const geometry = new TextGeometry(level, {
                        font: font,
                        size: 10,
                        height: 1,
                        curveSegments: 12,
                    });

                    const material = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: 0xffffff,
                        emissiveIntensity: 0,
                        transparent: true,
                        opacity: 0
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    scene.add(mesh);

                    // Center the text
                    geometry.computeBoundingBox();
                    mesh.position.x = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

                    // Make the option clickable
                    mesh.userData = { level: level };

                    // Animate level option appearance
                    const duration = 1000;
                    const startTime = Date.now() + delay;

                    function animateLevelOption() {
                        const elapsedTime = Date.now() - startTime;
                        if (elapsedTime < 0) {
                            requestAnimationFrame(animateLevelOption);
                            return;
                        }

                        const progress = Math.min(elapsedTime / duration, 1);

                        mesh.material.emissiveIntensity = progress * 0.2;
                        mesh.material.opacity = progress;
                        mesh.position.z = (1 - progress) * 20;

                        if (progress < 1) {
                            requestAnimationFrame(animateLevelOption);
                        }
                    }

                    animateLevelOption();
                }
            );
        }

        function animateCameraToPosition(x, y, z, duration = 1000) {
            const startPosition = camera.position.clone();
            const endPosition = new THREE.Vector3(x, y, z);
            const startTime = Date.now();

            function updateCamera() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                camera.position.lerpVectors(startPosition, endPosition, progress);
                controls.target.set(0, 0, 0);
                controls.update();

                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }

            updateCamera();
        }

        function transitionToGame() {
            const duration = 1000;
            const startTime = Date.now();

            function fadeOut() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                scene.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = 1 - progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(fadeOut);
                } else {
                    startGame();
                }
            }

            fadeOut();
        }
        function fadeInGame() {
            const duration = 1000; // 1 second transition
            const startTime = Date.now();

            function fadeIn() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                cubes.forEach(cube => {
                    cube.material.opacity = progress * 0.5; // Keep final opacity at 0.5
                    if (cube.line) {
                        cube.line.material.opacity = progress;
                    }
                });

                if (progress < 1) {
                    requestAnimationFrame(fadeIn);
                }
            }

            fadeIn();
        }

        function handleGameClick(intersectedObject) {
            if (!intersectedObject || !intersectedObject.isMesh) return;

            if (intersectedObject !== SELECTION) {
                if (SELECTION) {
                    const currentColor = SELECTION.material.color.getHex()
                    if (![COLORS.DEFAULT, COLORS.SELECTED].includes(currentColor)) {
                        SELECTION.currentHex = currentColor
                    }
                    SELECTION.material.color.setHex(SELECTION.locked ? COLORS.CORRECT : SELECTION.currentHex ?? COLORS.DEFAULT);
                    updateCubeLineColor(SELECTION, SELECTION.locked ? COLORS.CORRECT : 0xffffff);
                }
                SELECTION = intersectedObject;
                SELECTION.currentHex = SELECTION.material.color.getHex();
                SELECTION.material.color.setHex(COLORS.SELECTED);
                updateCubeLineColor(SELECTION, COLORS.SELECTED);
            } else if (SELECTION) {
                SELECTION.material.color.setHex(SELECTION.locked ? COLORS.CORRECT : SELECTION.currentHex);
                updateCubeLineColor(SELECTION, SELECTION.locked ? COLORS.CORRECT : 0xffffff);
                SELECTION = null;
            }
        }

        function startGame() {
            document.getElementById('score-display').style.display = 'block'
            scene.clear();
            loadPuzzle();
            createSettingsUI();
            centerCameraOnPuzzle();
            fadeInGame();

            // Add this code to trigger the keyboard on mobile devices
            const hiddenInput = document.createElement('input');
            hiddenInput.style.position = 'absolute';
            hiddenInput.style.opacity = '0';
            hiddenInput.style.height = '0';
            hiddenInput.style.fontSize = '16px'; // Prevents zoom on iOS
            document.body.appendChild(hiddenInput);
            hiddenInput.focus();

            // Add event listener for input changes
            hiddenInput.addEventListener('input', onMobileInput);
        }

        function onMobileInput(event) {
            const char = event.target.value.slice(-1).toUpperCase();
            event.target.value = ''; // Clear the input for the next key press
            handleInput(char);
        }


        function centerCameraOnPuzzle() {
            const puzzle = puzzles[settings.difficulty];
            const width = puzzle.words[0].length;
            const height = puzzle.words.length;

            const centerX = (width - 1) * 5; // 5 is half of the cube size (10)
            const centerY = -(height - 1) * 5;
            const centerZ = 0;

            // Set the camera position
            const distance = Math.max(width, height) * 15; // Adjust this multiplier as needed
            camera.position.set(centerX, centerY, distance);

            // Set the controls target to the center of the puzzle
            controls.target.set(centerX, centerY, centerZ);
            controls.update();
        }


        function createSettingsUI() {
            const settingsPanel = document.createElement("div");
            settingsPanel.id = "settings-panel";
            settingsPanel.style.position = "absolute";
            settingsPanel.style.top = "10px";
            settingsPanel.style.right = "10px";
            settingsPanel.style.backgroundColor = "rgba(255, 255, 255, 0.8)";
            settingsPanel.style.padding = "10px";
            settingsPanel.style.borderRadius = "5px";
            settingsPanel.style.zIndex = "1001";
            settingsPanel.style.display = "none";

            const showSolutionLabel = document.createElement("label");
            showSolutionLabel.innerHTML = `
                <input type="checkbox" id="show-solution" />
                Show Solution
            `;
            settingsPanel.appendChild(showSolutionLabel);

            document.body.appendChild(settingsPanel);

            const toggleSettingsButton = document.createElement("button");
            toggleSettingsButton.id = "toggle-settings";
            toggleSettingsButton.innerText = "Toggle Settings";
            toggleSettingsButton.style.position = "absolute";
            toggleSettingsButton.style.top = "10px";
            toggleSettingsButton.style.left = "10px";
            toggleSettingsButton.style.zIndex = "1001";
            document.body.appendChild(toggleSettingsButton);

            const checkSolutionButton = document.createElement("button");
            checkSolutionButton.id = "check-solution";
            checkSolutionButton.innerText = "Check Solution";
            checkSolutionButton.style.position = "absolute";
            checkSolutionButton.style.bottom = "10px";
            checkSolutionButton.style.left = "50vw";
            checkSolutionButton.style.zIndex = "1001";
            document.body.appendChild(checkSolutionButton);

            // UI event listeners
            document
                .getElementById("toggle-settings")
                .addEventListener("click", toggleSettings);
            document
                .getElementById("show-solution")
                .addEventListener("change", updateSettings);
            document
                .getElementById("check-solution")
                .addEventListener("click", checkSolution);

            // Initialize settings from UI
            updateSettingsFromUI();
        }

        function updateSettingsFromUI() {
            settings.showSolution = document.getElementById("show-solution").checked;
        }

        function toggleSettings() {
            const settingsPanel = document.getElementById("settings-panel");
            settingsPanel.style.display = settingsPanel.style.display === "none" ? "block" : "none";
        }

        function updateSettings() {
            updateSettingsFromUI();
            loadPuzzle();
        }

        function loadFont() {
            const loader = new FontLoader();
            loader.load(
                "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/fonts/helvetiker_bold.typeface.json",
                (response) => {
                    font = response;
                },
                (xhr) => {
                    console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
                },
                (err) => {
                    console.error("An error happened", err);
                }
            );
        }

        // Add these color constants at the top of your script
        const COLORS = {
            DEFAULT: 0xAD5C74, //Royal Heath
            MATCHING: 0x0000ff, // Blue
            CORRECT: 0x00ff00, // Green
            SELECTED: 0xffac03, // Orange
            INCORRECT: 0xc70039, // Crimson
            BUTTON_BACKGROUND: 0x22fec,
            BUTTON_BACKGROUND_HOVER: 0xffff,

        };

        // Modify the checkPatterns function
        function checkPatterns() {
            cubes.forEach((cube, index) => {
                const input = cube.input;

                const isMatching = cube.patterns.some((pattern) =>
                    pattern.test(input)
                );
                const isCorrect = input === cube.letter;

                if (isCorrect) {
                    cube.material.color.setHex(COLORS.CORRECT);
                    cube.locked = true
                    updateCubeLineColor(cube)
                } else if (isMatching) {
                    cube.material.color.setHex(COLORS.MATCHING);
                    cube.isMatching = true
                } else {
                    cube.material.color.setHex(COLORS.DEFAULT);
                    cube.isMatching = false
                }
            });
        }

        function makeCube(letter, x, y, z) {
            const size = 10;
            const buffer = 2;
            const position = new THREE.Vector3(x * size, -y * size, z * size);

            const cubeColor = COLORS.DEFAULT;
            const geometry = new THREE.BoxGeometry(
                size - buffer,
                size - buffer,
                size - buffer
            );
            const material = new THREE.MeshBasicMaterial({
                color: cubeColor,
                transparent: true,
                opacity: 0.5,
            });

            const cube = new THREE.Mesh(geometry, material);
            cube.position.copy(position);
            cube.letter = letter;
            cube.input = "";
            cube.selected = false;
            cube.size = size;
            cube.locked = false;
            cube.isMatching = false;
            cube.getCoordinates = () => [
                cube.position.x / cube.size,
                -cube.position.y / cube.size,
                cube.position.z / cube.size,
            ];

            scene.add(cube);

            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges,
                new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2, transparent: true, opacity: 0 })
            );
            line.position.copy(position);
            scene.add(line);
            cube.line = line;

            cube.patterns = [];
            cube.group = new THREE.Group();
            cube.group.position.copy(position);
            scene.add(cube.group);

            return cube;
        }

        function updateCubeLineColor(cube, color = undefined) {
            if (!cube || !cube.line || !cube.line.material) return;

            const lineColor = cube.locked ? COLORS.CORRECT : 0xffffff;
            cube.line.material.color.setHex(color ?? lineColor);
        }

        function createText(
            cube,
            text,
            color = 0xffffff,
            yOffset = 0,
            thickness = 1,
            zOffset = 0
        ) {
            const textGeometry = new TextGeometry(text, {
                font: font,
                size: 4,
                depth: thickness,
                curveSegments: 10,
            });

            const material = new THREE.MeshBasicMaterial({ color: color });
            const textMesh = new THREE.Mesh(textGeometry, material);
            textGeometry.computeBoundingBox();
            const centerOffset =
                -0.5 *
                (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
            const centerOffsetY =
                -0.5 *
                (textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y);
            textMesh.position.set(
                centerOffset,
                yOffset ? yOffset : centerOffsetY,
                zOffset
            );

            // Create a billboard object to hold the text
            const billboard = new THREE.Object3D();
            billboard.add(textMesh);
            cube.group.add(billboard);

            // Store the billboard in the cube for easy access later
            cube.textBillboard = billboard;

            return textMesh;
        }
        // Add this function to update billboard orientations
        function updateBillboards() {
            cubes.forEach((cube) => {
                if (cube.textBillboard) {
                    cube.textBillboard.lookAt(camera.position);
                }
            });
        }

        // Add this new function
        function dimOtherCubes(hoveredCube) {
            cubes.forEach((cube) => {
                if (cube !== hoveredCube) {
                    cube.material.opacity = 0.15; // Dim other cubes
                    if (cube.line) {
                        cube.line.material.opacity = 0.5; // Dim the outline
                    }
                } else {
                    cube.material.opacity = 0.6; // Keep the hovered cube fully opaque
                    if (cube.line) {
                        cube.line.material.opacity = 1; // Keep the outline fully opaque
                    }
                }
            });
        }

        // Add this new function
        function resetCubeDimming() {
            cubes.forEach((cube) => {
                cube.material.opacity = 0.5; // Reset to default opacity
                if (cube.line) {
                    cube.line.material.opacity = 1; // Reset outline opacity
                }
            });
        }


        function updateScore(points) {
            score += points;
            document.getElementById('score-display').textContent = `Score: ${score}`;
            updateScoreDisplay()
        }

        function onKeyDown(event) {
            if (!SELECTION || SELECTION.locked) return;

            if (event.key) {
                handleInput(event.key.toUpperCase());
            }
        }

        function handleInput(char) {
            if (!SELECTION || SELECTION.locked) return;

            if (/[A-Z]/.test(char) || char === "BACKSPACE") {
                if (char === "BACKSPACE") {
                    SELECTION.input = "";
                } else {
                    SELECTION.input = char;
                }
                updateDisplay();
                if (!SELECTION.locked) showHint(SELECTION);
                updateScore(-1);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateBillboards();
            renderer.render(scene, camera);
        }

        function loadPuzzle() {
            cubes.forEach((cube) => {
                scene.remove(cube);
                scene.remove(cube.group);
            });
            cubes.length = 0;

            const puzzle = puzzles[settings.difficulty];
            puzzle.words.forEach((word, y) => {
                word.split("").forEach((letter, x) => {
                    const cube = makeCube(letter, x, y, 0);
                    cube.patterns = [
                        puzzle.patterns[0][x] || /./, // Use /.*/ as a fallback
                        puzzle.patterns[1][y] || /./ // Use /.*/ as a fallback
                    ];
                    cubes.push(cube);
                });
            });
            // Set par value
            par = cubes.length + 1;
            score = par


            updateDisplay();
            updateScore(Number(score))
            updateScoreDisplay();
        }
        function updateScoreDisplay() {
            const scoreDiff = par - score;
            const scoreText = scoreDiff > 0 ? `+${scoreDiff}` : scoreDiff;
            document.getElementById('score-display').textContent = `Score: ${scoreText} (Par: ${par})`;
        }

        function showHint(cube) {
            const hintText = `${cube.patterns[0]
                .toString()
                .slice(1, -1)} / ${cube.patterns[1].toString().slice(1, -1)}`;
            createText(cube, hintText, 0xffff00, 6);
        }

        function showSolution() {
            cubes.forEach((cube) => {
                createText(cube, cube.letter, 0x00ff00, 0);
            });
        }

        function updateDisplay() {
            cubes.forEach((cube) => {
                cube.group.clear();
                if (cube.input) {
                    createText(cube, cube.input);
                }
            });

            if (settings.showSolution) {
                showSolution();
            }

            checkPatterns();
        }

        function checkSolution() {
            let allCorrect = true;
            let correctCount = 0;
            cubes.forEach((cube) => {
                const isCorrect = cube.input === cube.letter;
                allCorrect = allCorrect && isCorrect;
                if (isCorrect && !cube.locked) {
                    correctCount++;
                }
                animateCube(cube, isCorrect, cube.isMatching);
            });

            // Add points for correct answers
            updateScore(correctCount * 5);

            if (cubes.every(c => c.locked)) {
                celebrateWin();
            }
        }

        function celebrateWin() {
            const scoreDiff = (par - score) - 4;
            const particleCount = Math.max(20, 2000 - scoreDiff * 100); // Scale confetti based on score

            confetti({
                particleCount: particleCount,
                spread: 70,
                origin: { y: 1 }
            });

            setTimeout(() => {
                confetti({
                    particleCount: particleCount / 2,
                    angle: 60,
                    spread: 55,
                    origin: { x: 0 }
                });
                confetti({
                    particleCount: particleCount / 2,
                    angle: 120,
                    spread: 55,
                    origin: { x: 1 }
                });
            }, 250);

            setTimeout(() => {
                alert(`Congratulations! You've solved the puzzle!\nFinal Score: ${score}`);
                window.location.reload()
            }, 1000);
        }

        function animateCube(cube, isCorrect, isMatching) {
            const originalColor = cube.material.color.getHex();
            const animationColor = isCorrect ? COLORS.CORRECT : COLORS.INCORRECT;
            const animationDuration = 1200; // milliseconds
            const startTime = Date.now();

            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / animationDuration, 1);

                if (progress < 1) {
                    const currentColor = new THREE.Color(originalColor).lerp(
                        new THREE.Color(animationColor),
                        progress
                    );
                    cube.material.color.set(currentColor);
                    const lineColor = isCorrect ? COLORS.CORRECT : isMatching ? COLORS.MATCHING : COLORS.INCORRECT
                    updateCubeLineColor(cube, lineColor)
                    requestAnimationFrame(animate);
                } else {
                    if (isCorrect) {
                        cube.locked = true; // Lock the cube when correct
                        cube.material.color.setHex(COLORS.CORRECT);
                    } else {
                        cube.material.color.setHex(originalColor);
                    }
                    updateCubeLineColor(cube)
                }
            }

            animate();
        }

        init();
        animate();
    </script>
</body>

</html>